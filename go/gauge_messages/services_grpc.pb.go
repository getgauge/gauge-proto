//----------------------------------------------------------------
//  Copyright (c) ThoughtWorks, Inc.
//  Licensed under the Apache License, Version 2.0
//  See LICENSE in the project root for license information.
//----------------------------------------------------------------

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: services.proto

package gauge_messages

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Runner_ValidateStep_FullMethodName                   = "/gauge.messages.Runner/ValidateStep"
	Runner_InitializeSuiteDataStore_FullMethodName       = "/gauge.messages.Runner/InitializeSuiteDataStore"
	Runner_StartExecution_FullMethodName                 = "/gauge.messages.Runner/StartExecution"
	Runner_InitializeSpecDataStore_FullMethodName        = "/gauge.messages.Runner/InitializeSpecDataStore"
	Runner_StartSpecExecution_FullMethodName             = "/gauge.messages.Runner/StartSpecExecution"
	Runner_InitializeScenarioDataStore_FullMethodName    = "/gauge.messages.Runner/InitializeScenarioDataStore"
	Runner_StartScenarioExecution_FullMethodName         = "/gauge.messages.Runner/StartScenarioExecution"
	Runner_StartStepExecution_FullMethodName             = "/gauge.messages.Runner/StartStepExecution"
	Runner_ExecuteStep_FullMethodName                    = "/gauge.messages.Runner/ExecuteStep"
	Runner_FinishStepExecution_FullMethodName            = "/gauge.messages.Runner/FinishStepExecution"
	Runner_FinishScenarioExecution_FullMethodName        = "/gauge.messages.Runner/FinishScenarioExecution"
	Runner_FinishSpecExecution_FullMethodName            = "/gauge.messages.Runner/FinishSpecExecution"
	Runner_FinishExecution_FullMethodName                = "/gauge.messages.Runner/FinishExecution"
	Runner_CacheFile_FullMethodName                      = "/gauge.messages.Runner/CacheFile"
	Runner_GetStepName_FullMethodName                    = "/gauge.messages.Runner/GetStepName"
	Runner_GetGlobPatterns_FullMethodName                = "/gauge.messages.Runner/GetGlobPatterns"
	Runner_GetStepNames_FullMethodName                   = "/gauge.messages.Runner/GetStepNames"
	Runner_GetStepPositions_FullMethodName               = "/gauge.messages.Runner/GetStepPositions"
	Runner_GetImplementationFiles_FullMethodName         = "/gauge.messages.Runner/GetImplementationFiles"
	Runner_ImplementStub_FullMethodName                  = "/gauge.messages.Runner/ImplementStub"
	Runner_Refactor_FullMethodName                       = "/gauge.messages.Runner/Refactor"
	Runner_Kill_FullMethodName                           = "/gauge.messages.Runner/Kill"
	Runner_NotifyConceptExecutionStarting_FullMethodName = "/gauge.messages.Runner/NotifyConceptExecutionStarting"
	Runner_NotifyConceptExecutionEnding_FullMethodName   = "/gauge.messages.Runner/NotifyConceptExecutionEnding"
)

// RunnerClient is the client API for Runner service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RunnerClient interface {
	// ValidateStep is a RPC to validate a given step.
	//
	// Accepts a StepValidateRequest message and returns a StepValidateResponse message
	ValidateStep(ctx context.Context, in *StepValidateRequest, opts ...grpc.CallOption) (*StepValidateResponse, error)
	// SuiteDataStoreInit is a RPC to initialize the suite level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeSuiteDataStore(ctx context.Context, in *SuiteDataStoreInitRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ExecutionStarting is a RPC to tell runner to execute Suite level hooks.
	//
	// Accepts a ExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartExecution(ctx context.Context, in *ExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// SpecDataStoreInit is a RPC to initialize the spec level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeSpecDataStore(ctx context.Context, in *SpecDataStoreInitRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// SpecExecutionStarting is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartSpecExecution(ctx context.Context, in *SpecExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ScenarioDataStoreInit is a RPC to initialize the scenario level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeScenarioDataStore(ctx context.Context, in *ScenarioDataStoreInitRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ScenarioExecutionStarting is a RPC to tell runner to execute scenario level hooks.
	//
	// Accepts a ScenarioExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartScenarioExecution(ctx context.Context, in *ScenarioExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// StepExecutionStarting is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartStepExecution(ctx context.Context, in *StepExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ExecuteStep is a RPC to tell runner to execute a step .
	//
	// Accepts a ExecuteStepRequest message and returns a ExecutionStatusResponse message
	ExecuteStep(ctx context.Context, in *ExecuteStepRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// StepExecutionEnding is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishStepExecution(ctx context.Context, in *StepExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ScenarioExecutionEnding is a RPC to tell runner to execute Scenario level hooks.
	//
	// Accepts a ScenarioExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishScenarioExecution(ctx context.Context, in *ScenarioExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// SpecExecutionEnding is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishSpecExecution(ctx context.Context, in *SpecExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ExecutionEnding is a RPC to tell runner to execute suite level hooks.
	//
	// Accepts a ExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishExecution(ctx context.Context, in *ExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// CacheFile is a RPC to tell runner to load/reload/unload a implementation file.
	//
	// Accepts a CacheFileRequest message and returns a Empty message
	CacheFile(ctx context.Context, in *CacheFileRequest, opts ...grpc.CallOption) (*Empty, error)
	// GetStepName is a RPC to get information about the given step.
	//
	// Accepts a StepNameRequest message and returns a StepNameResponse message.
	GetStepName(ctx context.Context, in *StepNameRequest, opts ...grpc.CallOption) (*StepNameResponse, error)
	// GetGlobPatterns is a RPC to get the file path pattern which needs to be cached.
	//
	// Accepts a Empty message and returns a ImplementationFileGlobPatternResponse message.
	GetGlobPatterns(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileGlobPatternResponse, error)
	// GetStepNames is a RPC to get all the available steps from the runner.
	//
	// Accepts a StepNamesRequest message and returns a StepNamesResponse
	GetStepNames(ctx context.Context, in *StepNamesRequest, opts ...grpc.CallOption) (*StepNamesResponse, error)
	// GetStepPositions is a RPC to get positions of all available steps in a given file.
	//
	// Accepts a StepPositionsRequest message and returns a StepPositionsResponse message
	GetStepPositions(ctx context.Context, in *StepPositionsRequest, opts ...grpc.CallOption) (*StepPositionsResponse, error)
	// GetImplementationFiles is a RPC get all the existing implementation files.
	//
	// Accepts a Empty and returns a ImplementationFileListResponse message.
	GetImplementationFiles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileListResponse, error)
	// ImplementStub is a RPC to to ask runner to add a given implementation to given file.
	//
	// Accepts a StubImplementationCodeRequest and returns a FileDiff message.
	ImplementStub(ctx context.Context, in *StubImplementationCodeRequest, opts ...grpc.CallOption) (*FileDiff, error)
	// Refactor is a RPC to refactor a given step in implementation file.
	//
	// Accepts a RefactorRequest message and returns a RefactorResponse message.
	Refactor(ctx context.Context, in *RefactorRequest, opts ...grpc.CallOption) (*RefactorResponse, error)
	// Kill is a RPC tell plugin to stop grpc server and kill the plugin process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	Kill(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyConceptExecutionStarting is a RPC to tell plugins that the concept execution has started.
	//
	// Accepts a ConceptExecutionStartingRequest message and returns an ExecutionStatusResponse message
	NotifyConceptExecutionStarting(ctx context.Context, in *ConceptExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// NotifyConceptExecutionEnding is a RPC to tell plugins that the concept execution has finished.
	//
	// Accepts a ConceptExecutionEndingRequest message and returns an ExecutionStatusResponse message
	NotifyConceptExecutionEnding(ctx context.Context, in *ConceptExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
}

type runnerClient struct {
	cc grpc.ClientConnInterface
}

func NewRunnerClient(cc grpc.ClientConnInterface) RunnerClient {
	return &runnerClient{cc}
}

func (c *runnerClient) ValidateStep(ctx context.Context, in *StepValidateRequest, opts ...grpc.CallOption) (*StepValidateResponse, error) {
	out := new(StepValidateResponse)
	err := c.cc.Invoke(ctx, Runner_ValidateStep_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) InitializeSuiteDataStore(ctx context.Context, in *SuiteDataStoreInitRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_InitializeSuiteDataStore_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) StartExecution(ctx context.Context, in *ExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_StartExecution_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) InitializeSpecDataStore(ctx context.Context, in *SpecDataStoreInitRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_InitializeSpecDataStore_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) StartSpecExecution(ctx context.Context, in *SpecExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_StartSpecExecution_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) InitializeScenarioDataStore(ctx context.Context, in *ScenarioDataStoreInitRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_InitializeScenarioDataStore_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) StartScenarioExecution(ctx context.Context, in *ScenarioExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_StartScenarioExecution_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) StartStepExecution(ctx context.Context, in *StepExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_StartStepExecution_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) ExecuteStep(ctx context.Context, in *ExecuteStepRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_ExecuteStep_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) FinishStepExecution(ctx context.Context, in *StepExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_FinishStepExecution_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) FinishScenarioExecution(ctx context.Context, in *ScenarioExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_FinishScenarioExecution_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) FinishSpecExecution(ctx context.Context, in *SpecExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_FinishSpecExecution_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) FinishExecution(ctx context.Context, in *ExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_FinishExecution_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) CacheFile(ctx context.Context, in *CacheFileRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Runner_CacheFile_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetStepName(ctx context.Context, in *StepNameRequest, opts ...grpc.CallOption) (*StepNameResponse, error) {
	out := new(StepNameResponse)
	err := c.cc.Invoke(ctx, Runner_GetStepName_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetGlobPatterns(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileGlobPatternResponse, error) {
	out := new(ImplementationFileGlobPatternResponse)
	err := c.cc.Invoke(ctx, Runner_GetGlobPatterns_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetStepNames(ctx context.Context, in *StepNamesRequest, opts ...grpc.CallOption) (*StepNamesResponse, error) {
	out := new(StepNamesResponse)
	err := c.cc.Invoke(ctx, Runner_GetStepNames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetStepPositions(ctx context.Context, in *StepPositionsRequest, opts ...grpc.CallOption) (*StepPositionsResponse, error) {
	out := new(StepPositionsResponse)
	err := c.cc.Invoke(ctx, Runner_GetStepPositions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetImplementationFiles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileListResponse, error) {
	out := new(ImplementationFileListResponse)
	err := c.cc.Invoke(ctx, Runner_GetImplementationFiles_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) ImplementStub(ctx context.Context, in *StubImplementationCodeRequest, opts ...grpc.CallOption) (*FileDiff, error) {
	out := new(FileDiff)
	err := c.cc.Invoke(ctx, Runner_ImplementStub_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) Refactor(ctx context.Context, in *RefactorRequest, opts ...grpc.CallOption) (*RefactorResponse, error) {
	out := new(RefactorResponse)
	err := c.cc.Invoke(ctx, Runner_Refactor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) Kill(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Runner_Kill_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) NotifyConceptExecutionStarting(ctx context.Context, in *ConceptExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_NotifyConceptExecutionStarting_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) NotifyConceptExecutionEnding(ctx context.Context, in *ConceptExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, Runner_NotifyConceptExecutionEnding_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RunnerServer is the server API for Runner service.
// All implementations must embed UnimplementedRunnerServer
// for forward compatibility
type RunnerServer interface {
	// ValidateStep is a RPC to validate a given step.
	//
	// Accepts a StepValidateRequest message and returns a StepValidateResponse message
	ValidateStep(context.Context, *StepValidateRequest) (*StepValidateResponse, error)
	// SuiteDataStoreInit is a RPC to initialize the suite level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeSuiteDataStore(context.Context, *SuiteDataStoreInitRequest) (*ExecutionStatusResponse, error)
	// ExecutionStarting is a RPC to tell runner to execute Suite level hooks.
	//
	// Accepts a ExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartExecution(context.Context, *ExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// SpecDataStoreInit is a RPC to initialize the spec level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeSpecDataStore(context.Context, *SpecDataStoreInitRequest) (*ExecutionStatusResponse, error)
	// SpecExecutionStarting is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartSpecExecution(context.Context, *SpecExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// ScenarioDataStoreInit is a RPC to initialize the scenario level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeScenarioDataStore(context.Context, *ScenarioDataStoreInitRequest) (*ExecutionStatusResponse, error)
	// ScenarioExecutionStarting is a RPC to tell runner to execute scenario level hooks.
	//
	// Accepts a ScenarioExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartScenarioExecution(context.Context, *ScenarioExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// StepExecutionStarting is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartStepExecution(context.Context, *StepExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// ExecuteStep is a RPC to tell runner to execute a step .
	//
	// Accepts a ExecuteStepRequest message and returns a ExecutionStatusResponse message
	ExecuteStep(context.Context, *ExecuteStepRequest) (*ExecutionStatusResponse, error)
	// StepExecutionEnding is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishStepExecution(context.Context, *StepExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// ScenarioExecutionEnding is a RPC to tell runner to execute Scenario level hooks.
	//
	// Accepts a ScenarioExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishScenarioExecution(context.Context, *ScenarioExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// SpecExecutionEnding is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishSpecExecution(context.Context, *SpecExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// ExecutionEnding is a RPC to tell runner to execute suite level hooks.
	//
	// Accepts a ExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishExecution(context.Context, *ExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// CacheFile is a RPC to tell runner to load/reload/unload a implementation file.
	//
	// Accepts a CacheFileRequest message and returns a Empty message
	CacheFile(context.Context, *CacheFileRequest) (*Empty, error)
	// GetStepName is a RPC to get information about the given step.
	//
	// Accepts a StepNameRequest message and returns a StepNameResponse message.
	GetStepName(context.Context, *StepNameRequest) (*StepNameResponse, error)
	// GetGlobPatterns is a RPC to get the file path pattern which needs to be cached.
	//
	// Accepts a Empty message and returns a ImplementationFileGlobPatternResponse message.
	GetGlobPatterns(context.Context, *Empty) (*ImplementationFileGlobPatternResponse, error)
	// GetStepNames is a RPC to get all the available steps from the runner.
	//
	// Accepts a StepNamesRequest message and returns a StepNamesResponse
	GetStepNames(context.Context, *StepNamesRequest) (*StepNamesResponse, error)
	// GetStepPositions is a RPC to get positions of all available steps in a given file.
	//
	// Accepts a StepPositionsRequest message and returns a StepPositionsResponse message
	GetStepPositions(context.Context, *StepPositionsRequest) (*StepPositionsResponse, error)
	// GetImplementationFiles is a RPC get all the existing implementation files.
	//
	// Accepts a Empty and returns a ImplementationFileListResponse message.
	GetImplementationFiles(context.Context, *Empty) (*ImplementationFileListResponse, error)
	// ImplementStub is a RPC to to ask runner to add a given implementation to given file.
	//
	// Accepts a StubImplementationCodeRequest and returns a FileDiff message.
	ImplementStub(context.Context, *StubImplementationCodeRequest) (*FileDiff, error)
	// Refactor is a RPC to refactor a given step in implementation file.
	//
	// Accepts a RefactorRequest message and returns a RefactorResponse message.
	Refactor(context.Context, *RefactorRequest) (*RefactorResponse, error)
	// Kill is a RPC tell plugin to stop grpc server and kill the plugin process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	Kill(context.Context, *KillProcessRequest) (*Empty, error)
	// NotifyConceptExecutionStarting is a RPC to tell plugins that the concept execution has started.
	//
	// Accepts a ConceptExecutionStartingRequest message and returns an ExecutionStatusResponse message
	NotifyConceptExecutionStarting(context.Context, *ConceptExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// NotifyConceptExecutionEnding is a RPC to tell plugins that the concept execution has finished.
	//
	// Accepts a ConceptExecutionEndingRequest message and returns an ExecutionStatusResponse message
	NotifyConceptExecutionEnding(context.Context, *ConceptExecutionEndingRequest) (*ExecutionStatusResponse, error)
	mustEmbedUnimplementedRunnerServer()
}

// UnimplementedRunnerServer must be embedded to have forward compatible implementations.
type UnimplementedRunnerServer struct {
}

func (UnimplementedRunnerServer) ValidateStep(context.Context, *StepValidateRequest) (*StepValidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateStep not implemented")
}
func (UnimplementedRunnerServer) InitializeSuiteDataStore(context.Context, *SuiteDataStoreInitRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitializeSuiteDataStore not implemented")
}
func (UnimplementedRunnerServer) StartExecution(context.Context, *ExecutionStartingRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartExecution not implemented")
}
func (UnimplementedRunnerServer) InitializeSpecDataStore(context.Context, *SpecDataStoreInitRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitializeSpecDataStore not implemented")
}
func (UnimplementedRunnerServer) StartSpecExecution(context.Context, *SpecExecutionStartingRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartSpecExecution not implemented")
}
func (UnimplementedRunnerServer) InitializeScenarioDataStore(context.Context, *ScenarioDataStoreInitRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitializeScenarioDataStore not implemented")
}
func (UnimplementedRunnerServer) StartScenarioExecution(context.Context, *ScenarioExecutionStartingRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartScenarioExecution not implemented")
}
func (UnimplementedRunnerServer) StartStepExecution(context.Context, *StepExecutionStartingRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartStepExecution not implemented")
}
func (UnimplementedRunnerServer) ExecuteStep(context.Context, *ExecuteStepRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteStep not implemented")
}
func (UnimplementedRunnerServer) FinishStepExecution(context.Context, *StepExecutionEndingRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishStepExecution not implemented")
}
func (UnimplementedRunnerServer) FinishScenarioExecution(context.Context, *ScenarioExecutionEndingRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishScenarioExecution not implemented")
}
func (UnimplementedRunnerServer) FinishSpecExecution(context.Context, *SpecExecutionEndingRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishSpecExecution not implemented")
}
func (UnimplementedRunnerServer) FinishExecution(context.Context, *ExecutionEndingRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishExecution not implemented")
}
func (UnimplementedRunnerServer) CacheFile(context.Context, *CacheFileRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CacheFile not implemented")
}
func (UnimplementedRunnerServer) GetStepName(context.Context, *StepNameRequest) (*StepNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStepName not implemented")
}
func (UnimplementedRunnerServer) GetGlobPatterns(context.Context, *Empty) (*ImplementationFileGlobPatternResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGlobPatterns not implemented")
}
func (UnimplementedRunnerServer) GetStepNames(context.Context, *StepNamesRequest) (*StepNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStepNames not implemented")
}
func (UnimplementedRunnerServer) GetStepPositions(context.Context, *StepPositionsRequest) (*StepPositionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStepPositions not implemented")
}
func (UnimplementedRunnerServer) GetImplementationFiles(context.Context, *Empty) (*ImplementationFileListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImplementationFiles not implemented")
}
func (UnimplementedRunnerServer) ImplementStub(context.Context, *StubImplementationCodeRequest) (*FileDiff, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImplementStub not implemented")
}
func (UnimplementedRunnerServer) Refactor(context.Context, *RefactorRequest) (*RefactorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Refactor not implemented")
}
func (UnimplementedRunnerServer) Kill(context.Context, *KillProcessRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Kill not implemented")
}
func (UnimplementedRunnerServer) NotifyConceptExecutionStarting(context.Context, *ConceptExecutionStartingRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyConceptExecutionStarting not implemented")
}
func (UnimplementedRunnerServer) NotifyConceptExecutionEnding(context.Context, *ConceptExecutionEndingRequest) (*ExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyConceptExecutionEnding not implemented")
}
func (UnimplementedRunnerServer) mustEmbedUnimplementedRunnerServer() {}

// UnsafeRunnerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RunnerServer will
// result in compilation errors.
type UnsafeRunnerServer interface {
	mustEmbedUnimplementedRunnerServer()
}

func RegisterRunnerServer(s grpc.ServiceRegistrar, srv RunnerServer) {
	s.RegisterService(&Runner_ServiceDesc, srv)
}

func _Runner_ValidateStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ValidateStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_ValidateStep_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ValidateStep(ctx, req.(*StepValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_InitializeSuiteDataStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuiteDataStoreInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).InitializeSuiteDataStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_InitializeSuiteDataStore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).InitializeSuiteDataStore(ctx, req.(*SuiteDataStoreInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_StartExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).StartExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_StartExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).StartExecution(ctx, req.(*ExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_InitializeSpecDataStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecDataStoreInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).InitializeSpecDataStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_InitializeSpecDataStore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).InitializeSpecDataStore(ctx, req.(*SpecDataStoreInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_StartSpecExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).StartSpecExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_StartSpecExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).StartSpecExecution(ctx, req.(*SpecExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_InitializeScenarioDataStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioDataStoreInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).InitializeScenarioDataStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_InitializeScenarioDataStore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).InitializeScenarioDataStore(ctx, req.(*ScenarioDataStoreInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_StartScenarioExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).StartScenarioExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_StartScenarioExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).StartScenarioExecution(ctx, req.(*ScenarioExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_StartStepExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).StartStepExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_StartStepExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).StartStepExecution(ctx, req.(*StepExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_ExecuteStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteStepRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ExecuteStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_ExecuteStep_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ExecuteStep(ctx, req.(*ExecuteStepRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_FinishStepExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).FinishStepExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_FinishStepExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).FinishStepExecution(ctx, req.(*StepExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_FinishScenarioExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).FinishScenarioExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_FinishScenarioExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).FinishScenarioExecution(ctx, req.(*ScenarioExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_FinishSpecExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).FinishSpecExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_FinishSpecExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).FinishSpecExecution(ctx, req.(*SpecExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_FinishExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).FinishExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_FinishExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).FinishExecution(ctx, req.(*ExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_CacheFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CacheFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).CacheFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_CacheFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).CacheFile(ctx, req.(*CacheFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetStepName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetStepName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_GetStepName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetStepName(ctx, req.(*StepNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetGlobPatterns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetGlobPatterns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_GetGlobPatterns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetGlobPatterns(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetStepNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetStepNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_GetStepNames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetStepNames(ctx, req.(*StepNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetStepPositions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepPositionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetStepPositions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_GetStepPositions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetStepPositions(ctx, req.(*StepPositionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetImplementationFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetImplementationFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_GetImplementationFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetImplementationFiles(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_ImplementStub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StubImplementationCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ImplementStub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_ImplementStub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ImplementStub(ctx, req.(*StubImplementationCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_Refactor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefactorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).Refactor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_Refactor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).Refactor(ctx, req.(*RefactorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_Kill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).Kill(ctx, req.(*KillProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_NotifyConceptExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConceptExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).NotifyConceptExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_NotifyConceptExecutionStarting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).NotifyConceptExecutionStarting(ctx, req.(*ConceptExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_NotifyConceptExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConceptExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).NotifyConceptExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_NotifyConceptExecutionEnding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).NotifyConceptExecutionEnding(ctx, req.(*ConceptExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Runner_ServiceDesc is the grpc.ServiceDesc for Runner service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Runner_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gauge.messages.Runner",
	HandlerType: (*RunnerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateStep",
			Handler:    _Runner_ValidateStep_Handler,
		},
		{
			MethodName: "InitializeSuiteDataStore",
			Handler:    _Runner_InitializeSuiteDataStore_Handler,
		},
		{
			MethodName: "StartExecution",
			Handler:    _Runner_StartExecution_Handler,
		},
		{
			MethodName: "InitializeSpecDataStore",
			Handler:    _Runner_InitializeSpecDataStore_Handler,
		},
		{
			MethodName: "StartSpecExecution",
			Handler:    _Runner_StartSpecExecution_Handler,
		},
		{
			MethodName: "InitializeScenarioDataStore",
			Handler:    _Runner_InitializeScenarioDataStore_Handler,
		},
		{
			MethodName: "StartScenarioExecution",
			Handler:    _Runner_StartScenarioExecution_Handler,
		},
		{
			MethodName: "StartStepExecution",
			Handler:    _Runner_StartStepExecution_Handler,
		},
		{
			MethodName: "ExecuteStep",
			Handler:    _Runner_ExecuteStep_Handler,
		},
		{
			MethodName: "FinishStepExecution",
			Handler:    _Runner_FinishStepExecution_Handler,
		},
		{
			MethodName: "FinishScenarioExecution",
			Handler:    _Runner_FinishScenarioExecution_Handler,
		},
		{
			MethodName: "FinishSpecExecution",
			Handler:    _Runner_FinishSpecExecution_Handler,
		},
		{
			MethodName: "FinishExecution",
			Handler:    _Runner_FinishExecution_Handler,
		},
		{
			MethodName: "CacheFile",
			Handler:    _Runner_CacheFile_Handler,
		},
		{
			MethodName: "GetStepName",
			Handler:    _Runner_GetStepName_Handler,
		},
		{
			MethodName: "GetGlobPatterns",
			Handler:    _Runner_GetGlobPatterns_Handler,
		},
		{
			MethodName: "GetStepNames",
			Handler:    _Runner_GetStepNames_Handler,
		},
		{
			MethodName: "GetStepPositions",
			Handler:    _Runner_GetStepPositions_Handler,
		},
		{
			MethodName: "GetImplementationFiles",
			Handler:    _Runner_GetImplementationFiles_Handler,
		},
		{
			MethodName: "ImplementStub",
			Handler:    _Runner_ImplementStub_Handler,
		},
		{
			MethodName: "Refactor",
			Handler:    _Runner_Refactor_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _Runner_Kill_Handler,
		},
		{
			MethodName: "NotifyConceptExecutionStarting",
			Handler:    _Runner_NotifyConceptExecutionStarting_Handler,
		},
		{
			MethodName: "NotifyConceptExecutionEnding",
			Handler:    _Runner_NotifyConceptExecutionEnding_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

const (
	Reporter_NotifyExecutionStarting_FullMethodName         = "/gauge.messages.Reporter/NotifyExecutionStarting"
	Reporter_NotifySpecExecutionStarting_FullMethodName     = "/gauge.messages.Reporter/NotifySpecExecutionStarting"
	Reporter_NotifyScenarioExecutionStarting_FullMethodName = "/gauge.messages.Reporter/NotifyScenarioExecutionStarting"
	Reporter_NotifyConceptExecutionStarting_FullMethodName  = "/gauge.messages.Reporter/NotifyConceptExecutionStarting"
	Reporter_NotifyConceptExecutionEnding_FullMethodName    = "/gauge.messages.Reporter/NotifyConceptExecutionEnding"
	Reporter_NotifyStepExecutionStarting_FullMethodName     = "/gauge.messages.Reporter/NotifyStepExecutionStarting"
	Reporter_NotifyStepExecutionEnding_FullMethodName       = "/gauge.messages.Reporter/NotifyStepExecutionEnding"
	Reporter_NotifyScenarioExecutionEnding_FullMethodName   = "/gauge.messages.Reporter/NotifyScenarioExecutionEnding"
	Reporter_NotifySpecExecutionEnding_FullMethodName       = "/gauge.messages.Reporter/NotifySpecExecutionEnding"
	Reporter_NotifyExecutionEnding_FullMethodName           = "/gauge.messages.Reporter/NotifyExecutionEnding"
	Reporter_NotifySuiteResult_FullMethodName               = "/gauge.messages.Reporter/NotifySuiteResult"
	Reporter_Kill_FullMethodName                            = "/gauge.messages.Reporter/Kill"
)

// ReporterClient is the client API for Reporter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReporterClient interface {
	// NotifyExecutionStarting is a RPC to tell plugins that the execution has started.
	//
	// Accepts a ExecutionStartingRequest message and returns a Empty message
	NotifyExecutionStarting(ctx context.Context, in *ExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifySpecExecutionStarting is a RPC to tell plugins that the specification execution has started.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a Empty message
	NotifySpecExecutionStarting(ctx context.Context, in *SpecExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyScenarioExecutionStarting is a RPC to tell plugins that the scenario execution has started.
	//
	// Accepts a ScenarioExecutionStartingRequest message and returns a Empty message
	NotifyScenarioExecutionStarting(ctx context.Context, in *ScenarioExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyConceptExecutionStarting is a RPC to tell plugins that the concept execution has started.
	//
	// Accepts a ConceptExecutionStartingRequest message and returns a Empty message
	NotifyConceptExecutionStarting(ctx context.Context, in *ConceptExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyConceptExecutionEnding is a RPC to tell plugins that the concept execution has finished.
	//
	// Accepts a ConceptExecutionEndingRequest message and returns a Empty message
	NotifyConceptExecutionEnding(ctx context.Context, in *ConceptExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyStepExecutionStarting is a RPC to tell plugins that the step execution has started.
	//
	// Accepts a StepExecutionStartingRequest message and returns a Empty message
	NotifyStepExecutionStarting(ctx context.Context, in *StepExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyStepExecutionEnding is a RPC to tell plugins that the step execution has finished.
	//
	// Accepts a StepExecutionStartingRequest message and returns a Empty message
	NotifyStepExecutionEnding(ctx context.Context, in *StepExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyScenarioExecutionEnding is a RPC to tell plugins that the scenario execution has finished.
	//
	// Accepts a ScenarioExecutionEndingRequest message and returns a Empty message
	NotifyScenarioExecutionEnding(ctx context.Context, in *ScenarioExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifySpecExecutionEnding is a RPC to tell plugins that the specification execution has finished.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a Empty message
	NotifySpecExecutionEnding(ctx context.Context, in *SpecExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyExecutionEnding is a RPC to tell plugins that the execution has finished.
	//
	// Accepts a ExecutionEndingRequest message and returns a Empty message
	NotifyExecutionEnding(ctx context.Context, in *ExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifySuiteResult is a RPC to tell about the end result of execution
	//
	// Accepts a SuiteExecutionResult message and returns a Empty message.
	NotifySuiteResult(ctx context.Context, in *SuiteExecutionResult, opts ...grpc.CallOption) (*Empty, error)
	// Kill is a RPC tell plugin to stop grpc server and kill the plugin process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	Kill(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error)
}

type reporterClient struct {
	cc grpc.ClientConnInterface
}

func NewReporterClient(cc grpc.ClientConnInterface) ReporterClient {
	return &reporterClient{cc}
}

func (c *reporterClient) NotifyExecutionStarting(ctx context.Context, in *ExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Reporter_NotifyExecutionStarting_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifySpecExecutionStarting(ctx context.Context, in *SpecExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Reporter_NotifySpecExecutionStarting_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifyScenarioExecutionStarting(ctx context.Context, in *ScenarioExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Reporter_NotifyScenarioExecutionStarting_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifyConceptExecutionStarting(ctx context.Context, in *ConceptExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Reporter_NotifyConceptExecutionStarting_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifyConceptExecutionEnding(ctx context.Context, in *ConceptExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Reporter_NotifyConceptExecutionEnding_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifyStepExecutionStarting(ctx context.Context, in *StepExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Reporter_NotifyStepExecutionStarting_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifyStepExecutionEnding(ctx context.Context, in *StepExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Reporter_NotifyStepExecutionEnding_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifyScenarioExecutionEnding(ctx context.Context, in *ScenarioExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Reporter_NotifyScenarioExecutionEnding_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifySpecExecutionEnding(ctx context.Context, in *SpecExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Reporter_NotifySpecExecutionEnding_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifyExecutionEnding(ctx context.Context, in *ExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Reporter_NotifyExecutionEnding_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifySuiteResult(ctx context.Context, in *SuiteExecutionResult, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Reporter_NotifySuiteResult_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) Kill(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Reporter_Kill_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReporterServer is the server API for Reporter service.
// All implementations must embed UnimplementedReporterServer
// for forward compatibility
type ReporterServer interface {
	// NotifyExecutionStarting is a RPC to tell plugins that the execution has started.
	//
	// Accepts a ExecutionStartingRequest message and returns a Empty message
	NotifyExecutionStarting(context.Context, *ExecutionStartingRequest) (*Empty, error)
	// NotifySpecExecutionStarting is a RPC to tell plugins that the specification execution has started.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a Empty message
	NotifySpecExecutionStarting(context.Context, *SpecExecutionStartingRequest) (*Empty, error)
	// NotifyScenarioExecutionStarting is a RPC to tell plugins that the scenario execution has started.
	//
	// Accepts a ScenarioExecutionStartingRequest message and returns a Empty message
	NotifyScenarioExecutionStarting(context.Context, *ScenarioExecutionStartingRequest) (*Empty, error)
	// NotifyConceptExecutionStarting is a RPC to tell plugins that the concept execution has started.
	//
	// Accepts a ConceptExecutionStartingRequest message and returns a Empty message
	NotifyConceptExecutionStarting(context.Context, *ConceptExecutionStartingRequest) (*Empty, error)
	// NotifyConceptExecutionEnding is a RPC to tell plugins that the concept execution has finished.
	//
	// Accepts a ConceptExecutionEndingRequest message and returns a Empty message
	NotifyConceptExecutionEnding(context.Context, *ConceptExecutionEndingRequest) (*Empty, error)
	// NotifyStepExecutionStarting is a RPC to tell plugins that the step execution has started.
	//
	// Accepts a StepExecutionStartingRequest message and returns a Empty message
	NotifyStepExecutionStarting(context.Context, *StepExecutionStartingRequest) (*Empty, error)
	// NotifyStepExecutionEnding is a RPC to tell plugins that the step execution has finished.
	//
	// Accepts a StepExecutionStartingRequest message and returns a Empty message
	NotifyStepExecutionEnding(context.Context, *StepExecutionEndingRequest) (*Empty, error)
	// NotifyScenarioExecutionEnding is a RPC to tell plugins that the scenario execution has finished.
	//
	// Accepts a ScenarioExecutionEndingRequest message and returns a Empty message
	NotifyScenarioExecutionEnding(context.Context, *ScenarioExecutionEndingRequest) (*Empty, error)
	// NotifySpecExecutionEnding is a RPC to tell plugins that the specification execution has finished.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a Empty message
	NotifySpecExecutionEnding(context.Context, *SpecExecutionEndingRequest) (*Empty, error)
	// NotifyExecutionEnding is a RPC to tell plugins that the execution has finished.
	//
	// Accepts a ExecutionEndingRequest message and returns a Empty message
	NotifyExecutionEnding(context.Context, *ExecutionEndingRequest) (*Empty, error)
	// NotifySuiteResult is a RPC to tell about the end result of execution
	//
	// Accepts a SuiteExecutionResult message and returns a Empty message.
	NotifySuiteResult(context.Context, *SuiteExecutionResult) (*Empty, error)
	// Kill is a RPC tell plugin to stop grpc server and kill the plugin process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	Kill(context.Context, *KillProcessRequest) (*Empty, error)
	mustEmbedUnimplementedReporterServer()
}

// UnimplementedReporterServer must be embedded to have forward compatible implementations.
type UnimplementedReporterServer struct {
}

func (UnimplementedReporterServer) NotifyExecutionStarting(context.Context, *ExecutionStartingRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyExecutionStarting not implemented")
}
func (UnimplementedReporterServer) NotifySpecExecutionStarting(context.Context, *SpecExecutionStartingRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifySpecExecutionStarting not implemented")
}
func (UnimplementedReporterServer) NotifyScenarioExecutionStarting(context.Context, *ScenarioExecutionStartingRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyScenarioExecutionStarting not implemented")
}
func (UnimplementedReporterServer) NotifyConceptExecutionStarting(context.Context, *ConceptExecutionStartingRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyConceptExecutionStarting not implemented")
}
func (UnimplementedReporterServer) NotifyConceptExecutionEnding(context.Context, *ConceptExecutionEndingRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyConceptExecutionEnding not implemented")
}
func (UnimplementedReporterServer) NotifyStepExecutionStarting(context.Context, *StepExecutionStartingRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyStepExecutionStarting not implemented")
}
func (UnimplementedReporterServer) NotifyStepExecutionEnding(context.Context, *StepExecutionEndingRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyStepExecutionEnding not implemented")
}
func (UnimplementedReporterServer) NotifyScenarioExecutionEnding(context.Context, *ScenarioExecutionEndingRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyScenarioExecutionEnding not implemented")
}
func (UnimplementedReporterServer) NotifySpecExecutionEnding(context.Context, *SpecExecutionEndingRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifySpecExecutionEnding not implemented")
}
func (UnimplementedReporterServer) NotifyExecutionEnding(context.Context, *ExecutionEndingRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyExecutionEnding not implemented")
}
func (UnimplementedReporterServer) NotifySuiteResult(context.Context, *SuiteExecutionResult) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifySuiteResult not implemented")
}
func (UnimplementedReporterServer) Kill(context.Context, *KillProcessRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Kill not implemented")
}
func (UnimplementedReporterServer) mustEmbedUnimplementedReporterServer() {}

// UnsafeReporterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReporterServer will
// result in compilation errors.
type UnsafeReporterServer interface {
	mustEmbedUnimplementedReporterServer()
}

func RegisterReporterServer(s grpc.ServiceRegistrar, srv ReporterServer) {
	s.RegisterService(&Reporter_ServiceDesc, srv)
}

func _Reporter_NotifyExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reporter_NotifyExecutionStarting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyExecutionStarting(ctx, req.(*ExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifySpecExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifySpecExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reporter_NotifySpecExecutionStarting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifySpecExecutionStarting(ctx, req.(*SpecExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifyScenarioExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyScenarioExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reporter_NotifyScenarioExecutionStarting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyScenarioExecutionStarting(ctx, req.(*ScenarioExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifyConceptExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConceptExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyConceptExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reporter_NotifyConceptExecutionStarting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyConceptExecutionStarting(ctx, req.(*ConceptExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifyConceptExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConceptExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyConceptExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reporter_NotifyConceptExecutionEnding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyConceptExecutionEnding(ctx, req.(*ConceptExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifyStepExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyStepExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reporter_NotifyStepExecutionStarting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyStepExecutionStarting(ctx, req.(*StepExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifyStepExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyStepExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reporter_NotifyStepExecutionEnding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyStepExecutionEnding(ctx, req.(*StepExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifyScenarioExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyScenarioExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reporter_NotifyScenarioExecutionEnding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyScenarioExecutionEnding(ctx, req.(*ScenarioExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifySpecExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifySpecExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reporter_NotifySpecExecutionEnding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifySpecExecutionEnding(ctx, req.(*SpecExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifyExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reporter_NotifyExecutionEnding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyExecutionEnding(ctx, req.(*ExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifySuiteResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuiteExecutionResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifySuiteResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reporter_NotifySuiteResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifySuiteResult(ctx, req.(*SuiteExecutionResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reporter_Kill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).Kill(ctx, req.(*KillProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Reporter_ServiceDesc is the grpc.ServiceDesc for Reporter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Reporter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gauge.messages.Reporter",
	HandlerType: (*ReporterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NotifyExecutionStarting",
			Handler:    _Reporter_NotifyExecutionStarting_Handler,
		},
		{
			MethodName: "NotifySpecExecutionStarting",
			Handler:    _Reporter_NotifySpecExecutionStarting_Handler,
		},
		{
			MethodName: "NotifyScenarioExecutionStarting",
			Handler:    _Reporter_NotifyScenarioExecutionStarting_Handler,
		},
		{
			MethodName: "NotifyConceptExecutionStarting",
			Handler:    _Reporter_NotifyConceptExecutionStarting_Handler,
		},
		{
			MethodName: "NotifyConceptExecutionEnding",
			Handler:    _Reporter_NotifyConceptExecutionEnding_Handler,
		},
		{
			MethodName: "NotifyStepExecutionStarting",
			Handler:    _Reporter_NotifyStepExecutionStarting_Handler,
		},
		{
			MethodName: "NotifyStepExecutionEnding",
			Handler:    _Reporter_NotifyStepExecutionEnding_Handler,
		},
		{
			MethodName: "NotifyScenarioExecutionEnding",
			Handler:    _Reporter_NotifyScenarioExecutionEnding_Handler,
		},
		{
			MethodName: "NotifySpecExecutionEnding",
			Handler:    _Reporter_NotifySpecExecutionEnding_Handler,
		},
		{
			MethodName: "NotifyExecutionEnding",
			Handler:    _Reporter_NotifyExecutionEnding_Handler,
		},
		{
			MethodName: "NotifySuiteResult",
			Handler:    _Reporter_NotifySuiteResult_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _Reporter_Kill_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

const (
	Documenter_GenerateDocs_FullMethodName = "/gauge.messages.Documenter/GenerateDocs"
	Documenter_Kill_FullMethodName         = "/gauge.messages.Documenter/Kill"
)

// DocumenterClient is the client API for Documenter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DocumenterClient interface {
	// GenerateDocs is a RPC tell plugin to generate docs from the spec details.
	//
	// Accepts a SpecDetails message and returns a Empty message.
	GenerateDocs(ctx context.Context, in *SpecDetails, opts ...grpc.CallOption) (*Empty, error)
	// Kill is a RPC tell plugin to stop grpc server and kill the plugin process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	Kill(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error)
}

type documenterClient struct {
	cc grpc.ClientConnInterface
}

func NewDocumenterClient(cc grpc.ClientConnInterface) DocumenterClient {
	return &documenterClient{cc}
}

func (c *documenterClient) GenerateDocs(ctx context.Context, in *SpecDetails, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Documenter_GenerateDocs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documenterClient) Kill(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Documenter_Kill_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DocumenterServer is the server API for Documenter service.
// All implementations must embed UnimplementedDocumenterServer
// for forward compatibility
type DocumenterServer interface {
	// GenerateDocs is a RPC tell plugin to generate docs from the spec details.
	//
	// Accepts a SpecDetails message and returns a Empty message.
	GenerateDocs(context.Context, *SpecDetails) (*Empty, error)
	// Kill is a RPC tell plugin to stop grpc server and kill the plugin process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	Kill(context.Context, *KillProcessRequest) (*Empty, error)
	mustEmbedUnimplementedDocumenterServer()
}

// UnimplementedDocumenterServer must be embedded to have forward compatible implementations.
type UnimplementedDocumenterServer struct {
}

func (UnimplementedDocumenterServer) GenerateDocs(context.Context, *SpecDetails) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateDocs not implemented")
}
func (UnimplementedDocumenterServer) Kill(context.Context, *KillProcessRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Kill not implemented")
}
func (UnimplementedDocumenterServer) mustEmbedUnimplementedDocumenterServer() {}

// UnsafeDocumenterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DocumenterServer will
// result in compilation errors.
type UnsafeDocumenterServer interface {
	mustEmbedUnimplementedDocumenterServer()
}

func RegisterDocumenterServer(s grpc.ServiceRegistrar, srv DocumenterServer) {
	s.RegisterService(&Documenter_ServiceDesc, srv)
}

func _Documenter_GenerateDocs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecDetails)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumenterServer).GenerateDocs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Documenter_GenerateDocs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumenterServer).GenerateDocs(ctx, req.(*SpecDetails))
	}
	return interceptor(ctx, in, info, handler)
}

func _Documenter_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumenterServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Documenter_Kill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumenterServer).Kill(ctx, req.(*KillProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Documenter_ServiceDesc is the grpc.ServiceDesc for Documenter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Documenter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gauge.messages.Documenter",
	HandlerType: (*DocumenterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateDocs",
			Handler:    _Documenter_GenerateDocs_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _Documenter_Kill_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}
